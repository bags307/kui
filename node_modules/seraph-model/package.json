{
  "name": "seraph-model",
  "version": "0.6.18",
  "description": "thin model layer for seraph/neo4j",
  "main": "lib/model.js",
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha -R spec -t 360000"
  },
  "license": "MIT",
  "dependencies": {
    "async": "~0.1.22",
    "disposable-seraph": "^0.3.1",
    "moment": "~2.0.0",
    "underscore": "~1.5.0"
  },
  "devDependencies": {
    "mocha": "*",
    "disposable-seraph": "~0.3.0"
  },
  "readme": "__seraph_model__ provides some convenient functions for storing and retrieving\ntyped nodes from a neo4j database. It is intended to work with \n[seraph](https://github.com/brikteknologier/seraph). \n\n**using seraph-model < 0.6.0? please read [the changelist](#thechangelist)!**\n\n<a name=\"quick\"/>\n### Quick example\n\n```javascript\nvar db = require('seraph')('http://localhost:7474')\nvar model = require('seraph-model');\n\nvar User = model(db, 'user');\n\nUser.save({ name: 'Jon', city: 'Bergen' }, function(err, saved) {\n  if (err) throw err;\n\n  User.findAll(function(err, allUsers) {\n    // allUsers -> [{ name: 'Jon', city: 'Bergen', id: 0 }]\n  });\n  User.where({ city: 'Bergen' }, function(err, usersFromBergen) {\n    // usersFromBergen -> all user objects with city == bergen\n  });\n})\n\n```\n\n## Compatibility\n\nseraph-model 0.6.0 works with Neo4j-2.0.0 and higher.\n\nTo check if it works with your version, you should check out the repo, and\nchange the Neo4j version at the start of the tests to the version you're running\n\n## Changelist\n\nIs [here](#thechangelist).\n\n## License\n\nseraph-model is licensed with the MIT license.\n\n# Documentation\n\n## How to do things\n\n* [Creating a new Model](#create)\n* [Adding preparers](#preparation)\n* [Adding validators](#validation)\n* [beforeSave/afterSave events](#saveevents)\n* [Setting a properties whitelist](#settingfields)\n* [Composition of models](#composition)\n* [Setting a unique key](#uniqueness)\n* [Computed fields](#computed-fields)\n* [Schemas](#schemas)\n\n## Model instance methods\n* [model.read](#read)\n* [model.exists](#exists)\n* [model.save](#save)\n* [model.push](#push)\n* [model.saveComposition](#saveComposition)\n* [model.findAll](#findAll)\n* [model.where](#where)\n* [model.query](#query)\n* [model.prepare](#prepare)\n* [model.validate](#validate)\n* [model.fields](#fields)\n* [model.setUniqueKey](#setUniqueKey)\n* [model.useTimestamps](#useTimestamps)\n* [model.addComputedField](#addComputedField)\n* [model.addComputer](#addComputer)\n* [model.cypherStart](#cypherStart)\n\n<a name=\"create\"/>\n## Creating a new model\n\n__seraph_model(seraphDbObject, modelTypeName)__\n\nYou can create a new model by calling the function returned by requiring\n`seraph_model`. There are no instances of this model, only objects, which are \npassed to the model itself in order to perform work on it. Much like seraph\nitself.\n\nIt works by labelling each object with a `type` that you specify.\n\n### Example\n```javascript\nvar db = require('seraph')('http://localhost:7474');\nvar Beer = require('seraph_model')(db, 'beer');\n\nBeer.save({name: 'Pacific Ale', brewery: 'Stone & Wood'}, function(err, beer) {\n  // saved!\n});\n```\n\nAfter running this, your node is saved, and labelled as a `beer`, so a cypher\nquery like `MATCH node:beer RETURN node` would return your node.\n\n<a name=\"preparation\"/>\n## Adding preparers\n\n__Preparers__ are functions that are called upon an object to transform it\nbefore saving it. A preparer is a function that takes an object and a callback,\nand calls back with an error and the updated object.\n\nPreparers can also do validation. If a preparer returns an error, it will be\npassed to the save callback as if it were a validation error. However, if you\njust want to do validation and not mutate the object, use a\n[validator](#validation) instead.\n\nPreparers are called before validators.\n\nYou can manually prepare an object by using the [model.prepare](#prepare)\nfunction.\n\n### Example\n\n```javascript\nvar prepareFileSize = function(object, callback) {\n  fs.stat(object.file, function(err, stat) {\n    if (err) return callback('There was an error finding the file size');\n    object.filesize = stat.size;\n    callback(null, object);\n  });\n}\n\nmodel.on('prepare', prepareFileSize);\n\nmodel.save({file: 'foo.txt'}, function(err, object) {\n  // object -> { file: 'foo.txt', filesize: 521, id: 0 }\n});\n\nmode.save({file: 'nonexistant.txt'}, function(err, object) {\n  // err -> 'There was an error finding the file size'\n});\n```\n\n<a name=\"validation\"/>\n## Adding validators\n__Validators__ are functions that are called with an object before it is saved.\nIf they call back with anything that is not falsy, the saving process is halted,\nand the error from the validator function is returned to the save callback.\n\nValidators are called after preparers.\n\nYou can manually validate an object by using the [model.validate](#validate)\nfunction.\n\n### Example\n\n```javascript\nvar validateAge = function(person, callback) {\n  if (object.age >= 21) {\n    callback();\n  } else {\n    callback('You must be 21 or older to sign up!');\n  }\n}\n\nmodel.on('validate', validateAge);\n\nmodel.save({ name: 'Jon', age: 23 }, function(err, person) {\n  // person -> { name: 'Jon', age: 23, id: 0 }\n});\n\nmodel.save({ name: 'Jordan', age: 17 }, function(err, person) {\n  // err -> 'You must be 21 or older to sign up!'\n});\n```\n\n<a name=\"saveevents\"/>\n## Save events\n\nThere's a few events you can listen on:\n\n* `beforeSave` fired after preparation and validation, but before saving.\n* `afterSave` fired after saving. \n\n### Example\n\n```javascript\nmodel.on('beforeSave', function(obj) {\n  console.log(obj, \"is about to be saved\");\n})\n```\n\n<a name=\"settingfields\"/>\n## Setting a properties whitelist\n\n__Fields__ are a way of whitelisting which properties are allowed on an object \nto be saved. Upon saving, all properties which are not in the whitelist are \nstripped. Composited properties are automatically whitelisted.\n\n### Example\n\n```javascript\nbeer.fields = ['name', 'brewery', 'style'];\n\nbeer.save({\n  name: 'Rye IPA', \n  brewery: 'Lervig', \n  style: 'IPA',\n  country: 'Norway'\n}, function(err, theBeer) {\n  // theBeer -> { name: 'Rye IPA', brewery: 'Lervig', style: 'IPA', id: 0 }\n})\n```\n\n<a name=\"composition\"/>\n## Composition of Models.\n\nComposition allows you to relate two models so that you can save nested objects\nfaster, and atomically. When two models are composed, even though you might be\nsaving 10 objects, only 1 api call will be made.\n\nWith this, you can also nest objects, which can make your life a bit easier when\nsaving large graphs of different objects.\n\n**Composited objects will also be implicitly retrieved when reading from the\ndatabase, to a specified depth.**.\n\nBecause of this, you should be careful and sparing about what you compose. Compose\nonly those models which you want to have *every time* you read an instance of this\nmodel.\n\n**example**\n\n```javascript\nvar beer = model(db, \"Beer\");\nvar hop = model(db, \"Hop\");\n\nbeer.compose(hop, 'hops', 'contains_hop');\n\nvar pliny = {\n  name: 'Pliny the Elder',\n  brewery: 'Russian River',\n  hops: [\n    { name: 'Columbus', aa: '13.9%' },\n    { name: 'Simcoe', aa: '12.3%' },\n    { name: 'Centennial', aa: '8.0%' }\n  ]\n};\n\n// Since objects were listed on the 'hops' key that I specified, they will be \n// saved with the `hop` model, and then related back to my beer.\nbeer.save(pliny, function(err, saved) {\n  // if any of the hops or the beer failed validation with their model, err\n  // will be populated and nothing will be saved.\n  \n  console.log(saved); \n  /* -> { brewery: 'Russian River',\n          name: 'Pliny the Elder',\n          id: 11,\n          hops: \n           [ { name: 'Columbus', aa: '13.9%', id: 12 },\n             { name: 'Simcoe', aa: '12.3%', id: 13 },\n             { name: 'Centennial', aa: '8.0%', id: 14 } ] }\n  */\n\n  db.relationships(saved, function(err, rels) {\n    console.log(rels) // -> [ { start: 11, end: 12, type: 'contains_hop', properties: {}, id: 0 },\n                      // { start: 11, end: 13, type: 'contains_hop', properties: {}, id: 1 },\n                      // { start: 11, end: 14, type: 'contains_hop', properties: {}, id: 2 } ]\n  });\n\n  // Read directly with seraph\n  db.read(saved, function(err, readPlinyFromDb) {\n    console.log(readPliny)\n    /* -> { brewery: 'Russian River',\n            name: 'Pliny the Elder',\n            id: 11 }\n    */\n  })\n\n  // Read with model, and you get compositions implicitly.\n  beer.read(saved, function(err, readPliny) {\n    console.log(readPliny)\n    /* -> { brewery: 'Russian River',\n            name: 'Pliny the Elder',\n            id: 11,\n            hops: \n             [ { name: 'Columbus', aa: '13.9%', id: 12 },\n               { name: 'Simcoe', aa: '12.3%', id: 13 },\n               { name: 'Centennial', aa: '8.0%', id: 14 } ] }\n    */\n  });\n\n  hop.read(14, function(err, hop) {\n    console.log(hop); // -> { name: 'Centennial', aa: '8.0%', id: 14 }\n  });\n});\n```\n\n### Updating models with compositions\n\nYou can use the regular `model.save` function to update a model with \ncompositions on it. If the compositions differ from the previous version of the\nmodel, the relationships to the previously composed nodes will be deleted **but\nthe nodes themselves will not be**. If you want to update the base model but\ndon't want the overhead that the compositions involves, you can use `model.save`\nwith `excludeCompositions` set to true. See the [model.save](#save) docs for\nmore info.\n\nA couple of alternatives for updating compositions exist: [`model.push`](#push)\nfor pushing a single object to a composition without having to first read the\nmodel from the database, and [`model.saveComposition`](#saveComposition) for \nupdating an entire composition in one go.\n\n### model.compose(composedModel, key, relationshipName[, opts])\n\nAdd a composition.\n\n* `composedModel` — the model which is being composed\n* `key` — the key on an object being saved which will contained the composed \n  models.\n* `relationshipName` — the name of the relationship that is created between\n  a root model and its composed models. These relationships are always outgoing.\n* `opts` - an object with a set of options. possible options are documented\n  below.\n\n#### composition options\n\n* `many` (default = `false`) — whether this is a *-to-many relationship. If \n  truthy, the this composition will always be represented as an array on the \n  base object.\n* `orderBy` (default = `null`) - how this composition should be ordered. This\n  can be set to either the name of a property on the composed node to order with\n  (ascending), or an object with the name of the property value and the order\n  direction. Possible values might include: `'age'`, \n  `{property: 'age', desc: true}`, `{property: 'age', desc: false}`.\n* `updatesTimestamp`: (default = `false`) - if true, whenever a composed model is\n  saved, it will update the `updated` timestamp of the root model. Does nothing\n  if `this` is not using timestamps.\n\n### model.readComposition(objectOrId, compositionKey, callback)\n\nRead a single composition from a model.\n\n* `objectOrId` — an id or an object that contains an id that refers to a model.\n* `compositionKey` – the composition which to retrieve.\n* `callback` — callback for result, format (err, resultingComp). `resulingComp`\n  will either be an array of composed objects or a single object if there was\n  only one\n\nExample (from the above context)\n```javascript\nbeer.readComposition(pliny, 'hops', function(err, hops) {\n  console.log(hops); \n  /* [ { name: 'Columbus', aa: '13.9%', id: 12 },\n      { name: 'Simcoe', aa: '12.3%', id: 13 },\n      { name: 'Centennial', aa: '8.0%', id: 14 } ]  */\n});\n```\n<a name=\"uniqueness\"/>\n## Setting a unique key \n\nIn neo4j, you can enforce uniqueness of nodes by using a uniqueness constraint\non a given key for a label. You can add this constraint yourself, but doing so\nthrough seraph-model will give you the option to use the existing node in the event of a \nconflict. \n\n### Unique Key\n\nSpecifiying a unique key will create a constraint on that key. This means that\nno two nodes saved as this kind of model can have the same value for that key.\n\nFor example:\n\n```javascript\nvar Car = model(db, 'car');\nCar.setUniqueKey('model');\nCar.save({make: 'Citroën', model: 'DS4'}, function(err, ds4) {\n  // ds4 -> { id: 1, make: 'Citroën', model: 'DS4' }\n  Car.save({make: 'Toyota', model: 'DS4'}, function(err, otherDs4) {\n    // err.statusCode -> 409 (conflict)\n  });\n});\n\nCar.save({make: 'Subaru'}, function(err, subaru) {\n  // err -> 'The `model` key is not set, but is required to save this object'\n});\n```\n\nYou can also specify that instead of returning a conflict error, that you want\nto just return the old object when you attempt to save a new one at the same\nindex. For example:\n\n```javascript\nvar Tag = model(db, 'tag');\nTag.setUniqueKey('tag', true);\nTag.save({tag: 'finnish'}, function(err, tag) {\n  // tag -> { id: 1, tag: 'finnish' }\n  \n  // presumably later on, someone wants to save the same tag \n  Tag.save({tag: 'finnish'}, function(err, tag) {\n    // instead of saving another tag 'finnish', the first one was returned\n    // tag -> { id: 1, tag: 'finnish' }\n  });\n});\n```\n\n<a name=\"computed-fields\"/>\n## Computed fields\n\nComputed fields are fields on a model that exist transiently (they aren't stored\nin the database) and can be composed of other fields on the object or external\ninformation. You specify the field that you want to be computed, and the function \nthat should be used to compute the value of that field for the model, and it will \nautomatically be computed every time the model is read (and removed from the\nmodel just before saving). You can use [addComputedField](#addComputedField) or\n[addComputer](#addComputer) to add a computed field.\n\nExample:\n\n```\nvar Car = model(db, 'car');\nCar.addComputedField('name', function(car) {\n  return car.make + ' ' + car.model;\n});\nCar.addComputedField('popularity', function(car, cb) {\n  fetchPopularityRating(car.make, car.model, function(err, rating) {\n    if (err) return cb(err);\n    cb(null, rating.numberOfOwners);\n  });\n});\n\nCar.save({ make: 'Citroën', model: 'DS4' }, function(err, car) {\n  // car.name = 'Citroën DS4'\n  // car.popularity = 8599\n});\n```\n\n<a name=\"schemas\"/>\n## Schemas\n\nSchemas are a way of defining some constraints on a model and enforcing them\nwhile saving. An example of a schema might be:\n\n```javascript\nvar User = model(db, 'user');\nUser.schema = {\n  name: { type: String, required: true },\n  email: { type: String, match: emailRegex, required: true },\n  age: { type: Number, min: 16, max: 85 },\n  expiry: Date\n}\n```\n\nSetting a schema will automatically use the keys of the schema as the model's\n[`fields`](#fields) property.\n\nEach of the constraints and their behaviour are explained below.\n\n* [`type`](#schema.type)\n  + [`'date'` or `Date`](#schema.type.date)\n  + [`'string'` or `String`](#schema.type.string)\n  + [`'number'` or `Number`](#schema.type.number)\n  + [`'array'` or `Array`](#schema.type.number)\n  + [`'boolean'` or `Boolean`](#schema.type.number)\n  + [Other types](#schema.type.others)\n* [`default`](#schema.default)\n* [`trim`](#schema.trim)\n* [`lowercase`](#schema.lowercase)\n* [`uppercase`](#schema.uppercase)\n* [`required`](#schema.required)\n* [`match`](#schema.match)\n* [`enum`](#schema.enum)\n* [`min`](#schema.min)\n* [`max`](#schema.max)\n\n<a name=\"schema.type\">\n### `type`\n\nA `type` property on the schema indicates the type that this property should be.\nUpon saving, seraph-model will attempt to coerce properties that have a `type`\nspecified into that type.\n\n<a name=\"schema.type.date\"/>\n#### `'date'` or `Date`\n\nExpects a date, and coerces it to a number using [`Date.getTime`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime).\nValues will be parsed using [Moment.js' date parser](http://momentjs.com/docs/#/parsing/).\n\nExamples of coercion:\n\n```\nnew Date(\"2013-02-08T09:30:26\")    ->   1360315826000\n\"2013-02-08T09:30:26\"              ->   1360315826000\n1360315826000                      ->   1360315826000\n```\n\n<a name=\"schema.type.string\"/>\n#### `'string'` or `String`\n\nExpects a string. Values will be coerced to a string using `.toString()`.\n\n<a name=\"schema.type.number\"/>\n#### `'number'` or `Number`\n\nExpects a number. Values will be coerced to a number. If the coercion results\nin `NaN`, validation will fail.\n\n<a name=\"schema.type.boolean\"/>\n#### `'boolean'` or `Boolean`\n\nExpects a boolean. Values that are not already a boolean will be coerced based on\ntheir truthiness (i.e. `!!value`), with the exception of `'0'` which is coerced\nto `false`.\n\n<a name=\"schema.type.array\"/>\n#### `'array'` or `Array`\n\nExpects an array. If the value is not an array, it will be coerced to an array\nby inserting the value into an array and returning that.\n\nExamples of coercion:\n\n```\n[1,2,3]     -> [1,2,3]\n'cat'       -> ['cat']\n```\n\n<a name=\"schema.type.others\"/>\n#### Other types\n\nYou can give your own types to check against. If `type` is set to a string value\nthat is not one of the above, the value's type is checked with \n`typeof value == type`. If `type` is a function, the value's type is checked with\n`value instanceof type`. \n\n<a name=\"schema.default\"/>\n### `default`\n\nSupply a default value for this property. If the property is undefined or null\nupon saving, the property will be set to this value.\n\n**Default value:** `undefined`.\n**Example values:** `'Anononymous User'`, `500`, `[1, 2, 3]`. \n\nExample:\n\n```javascript\nUser.schema = {\n  name: { default: 'Anonymous User' }\n}\n```\n\n<a name=\"schema.trim\"/>\n### `trim`\n\nTrim leading/trailing whitespace from a string.\n\n**Default value:** `false`.\n**Example values:** `true`, `false`. \n\n<a name=\"schema.uppercase\"/>\n### `uppercase`\n\nTransform a string to uppercase.\n\n**Default value:** `false`.\n**Example values:** `true`, `false`. \n\n<a name=\"schema.lowercase\"/>\n### `lowercase`\n\nTransform a string to lowercase.\n\n**Default value:** `false`.\n**Example values:** `true`, `false`. \n\n<a name=\"schema.required\"/>\n### `required`\n\nEnsure this property exists. Validation will fail if it null or undefined.\n\n**Default value:** `false`.\n**Example values:** `true`, `false`. \n\n<a name=\"schema.match\"/>\n### `match`\n\nValues should match this regular expression. Validation will value if the value\ndoes not.\n\n**Default value:** `undefined`.\n**Example values:** `/^user/i`, `new RegExp(\"^user\", \"i\")`. \n\n<a name=\"schema.enum\"/>\n### `enum`\n\nValues should be one of the values in the enum. Validation will fail if the value\nis not in the enum.\n\n**Default value:** `undefined`.\n**Example values:** `['male', 'female']`, `[10, 20, 30]`. \n\n<a name=\"schema.min\"/>\n### `min`\n\nValues should be greater than or equal to the given number. Validation will fail\nif the value is less.\n\n**Default value:** `undefined`.\n**Example values:** `10`, `0.05`. \n\n<a name=\"schema.max\"/>\n### `max`\n\nValues should be less than or equal to the given number. Validation will fail\nif the value is greater.\n\n**Default value:** `undefined`.\n**Example values:** `100`, `0.95`. \n\n<a name=\"save\"/>\n#### `model.save(object, [excludeCompositions,] callback(err, savedObject))`\n\nSaves or updates an object in the database. The steps for doing this are:\n\n1. `object` is prepared using [model.prepare](#prepare)\n2. `object` is validated using [model.validate](#validate). If validation\n   fails, the callback is called immediately with an error.\n3. The `beforeSave` event is fired.\n4. A cypher query is assembled that will save/update the node with the appropriate\n   label, as well as any relevant composited nodes.\n5. `object` is saved.\n6. The `afterSave` event is fired.\n\nIf `excludeCompositions` is truthy, any composed models attached to `object`\nwill not be altered in the database (they will be ignored), and the object which \nis returned will exclude compositions.\n\n<a name=\"push\"/>\n#### `model.push(rootId, compName, object(s), callback(err, savedObject(s)))`\n\nPushes a single object as a composed model on the model represented by `rootId`.\nThis does not read the database first so there is no danger of a race condition.\n\n<a name=\"saveComposition\"/>\n#### `model.saveComposition(rootId, compName, objects, callback(err, savedObjects))`\n\nUpdates a composition set on a model. The models composed under `compName` on the\nmodel will be replaced with those specified by objects. This can be a partial\nupdate if you have an already existing array of composited objects.\n\n<a name=\"read\"/>\n#### `model.read(idOrObject, callback(err, model))`\n\nReads a model from the database given an id or an object containing the id. \n`model` is either the returned object or `false` if it was not found.\n\n<a name=\"exists\"/>\n#### `model.exists(idOrObject, callback(err, doesExist))`\n\nCheck if a model exists.\n\n<a name=\"findAll\"/>\n#### `model.findAll([opts,] callback(err, allOfTheseModels))`\n\nFinds all of the objects that were saved with this type. Returns composited nodes.\n\n`opts` is a set of options to pass to the read call. See [query](#query) for\navailable settings.\n\n<a name=\"where\"/>\n#### `model.where(predicate, [opts,] callback(err, matchingModels))`\n\nThis is a operationally similar to \n[seraph.find](https://github.com/brikteknologier/seraph#node.find), but is\nrestricted to searching for nodes marked as this kind of model only. Will also\nreturn composited nodes.\n\n`predicate` can also contain Javascript RegExp objects for some values. For instance, to make a case \ninsensitive request, one might use :\n\n```javascript\nCar.where({ make: new RegExp('Aston Martin', 'i') }, { varName: \"car\" }, function(err, cars) {\n  // `cars` might have 'ASTON MARTIN', 'aston martin', 'AsToN mArTiN' (and many others) as `make` values... as long as James Bond's driving.\n});\n```\n\n`opts` is a set of options to pass to the [query](#query) call. Special options\nfor `where`:\n\n* `any` (default = `false`) - if set to true, will match nodes with any of the\n  specified values, rather than nodes with all of them. \n\n<a name=\"query\"/>\n#### `model.query(query, params, [opts,] callback)`\n\nTakes a partial cypher query and extends it to retrieve seraph-models of this \ntype. This is useful if you have computed properties or compositions. The `query`\nshould be a regular cypher query, but it should not have a RETURN statement. It\nshould also have a `node` variable (name is configurable via the `opts.varName`\nsetting) that represents the model. So for example, lets say I want to find\nall Cars with an age greater than `x` years. I might do a query like this:\n\n**Available options**\n\n* `varName` (default = `node`) - the variable name in the query referring to\n  nodes of the current model.\n* `skip` (default = 0) - skip this many nodes in the resultset (exactly the same\n  as cypher's SKIP)\n* `limit` (default = none) - limit to this many results (exactly the same as\n  cypher's LIMIT)\n* `orderBy` - an order by clause. to order by a property, use `varName` as well.\n  For example, if `varName` is `beer`, I can have a `orderBy` value of `beer.abv DESC`.\n* `otherVars` - an array of other variable names that you want to return. they \n  will be attached to each node in the result. for example if you have a variable\n  in your query `age`, and you specify it in `otherVars`, its value will be returned\n  on each return model as the `age` property. Note that if a property with that\n  name already exists, it will be overwritten (on the client, not in the database)\n* `include` - an array of included models. These are models which are related to\n  the model you'd like to retrieve, but not composed. Specifying them here will\n  automatically fetch these relations, and run any computations for that model\n  after reading. It's also just convenient so that you don't have to specify your\n  own MATCHes when you have non-composed relations. `include` should be an object,\n  where each key is the name of the property on the resulting node, and each value\n  is an object with the following options:\n  * `model` the seraph-model that will be read\n  * `rel` the relationship relating the root node and this model\n  * `direction` (optional - default: `out`) the direction of the relationship\n  * `many` (optional - default: `false`) if set to true, the result is always\n    and array\n* `computeLevels` - compute computed variables on models up to this depth in the\n  composition graph. This may be desirable if you are reading many nodes, and\n  you have computations that cause a database query to be executed. This can\n  grow very quickly to a lot of http calls, and so `computeLevels` can be used\n  to restrict the computation to only your root model (0) or the closest\n  compositions (1, etc).\n  \n\n```javascript\nCar.query('MATCH (car:car) WHERE car.age > {x}', { x: 10 }, { varName: 'car' }, function(err, cars) {\n  // `cars` is always an array\n});\n```\n\n<a name=\"prepare\"/>\n#### `model.prepare(object, callback(err, preparedObject))`\n\nPrepares an object by using the `model.preparers` array of functions to mutate\nit. For more information, see [Adding preparers](#preparation)\n\n<a name=\"validate\"/>\n#### `model.validate(object, callback(err, preparedObject))`\n\nValidates that an object is ready for saving by calling each of the functions in\nthe `model.validators` array. For more information, see \n[Adding validators](#validation)\n\n<a name=\"fields\"/>\n#### `model.fields`\n\nThis is an array of property names which acts as a whitelist for property names\nin objects to be saved. If it is set, any properties in objects to be saved that\nare not included in this array are stripped. Composited properties are \nautomatically whitelisted. See \n[Setting a properties whitelist](#settingfields) for more information and\nexamples.\n\n<a name=\"setUniqueKey\"/>\n#### `model.setUniqueKey(keyName, [returnOldOnConflict = false], [callback])`\n\nAdds a uniqueness constraint to the database that makes sure `keyName` has a\nunique value for any nodes labelled as this kind of model. If the constraint\nalready exists, no changes are made.\n\nSee the [using a unique key](#unique-key) section for more information and\nexamples.\n\n<a name=\"useTimestamps\"/>\n#### `model.useTimestamps([createdField = 'created', [updatedField = 'updated'])`\n\nIf called, the model will add a `created` and `updated` timestamp field to each\nmodel that is saved. These are timestamps based on the server's time (in ms). \n\nYou can also use the `model.touch(node, callback)` function to update the\n`updated` timestamp without changing any of the node's properties. This is useful\nif you're updating composed models seperately but still want the base model to\nbe updated.\n\n<a name=\"addComputedField\"/>\n#### `model.addComputedField(fieldName, computer)`\n\nAdd a [computed field](#computed-fields) to a model.\n\n<a name=\"addComputer\"/>\n#### `model.addComputer(fieldNameArray, computer)`\n\nAdd multiple [computed fields](#computed-fields) to a model, that are computed\nwith a single computer. `computer` is a function that takes arguments `obj` and\n`callback`, and calls a callback with `err` and a modified `obj` with the computed\nfields added. `fieldNameArray` is an array of names of computed properties. These\nneed to be known so that they will not be persisted back into the database.\n\n<a name='thechangelist'/>\n# Changelist\n\n## 0.6.0\n\nSee [migration guide](#migration) for details on migrating from 0.5.0 to 0.6.0.\nIf you've been using 0.5.0 this is mandatory, your models won't work if you don't\nmigrate.\n\n* Models now use [labels](http://docs.neo4j.org/chunked/milestone/graphdb-neo4j-labels.html) (new in neo4j 2) instead of legacy indexes to keep track of their type.\n* Removed all legacy indexing. Any legacy indexes you use should be now created\n  manually. The `afterSave` or `beforeSave` events are recommended for this\n  purpose.\n* `setUniqueKey` now uses neo4j 2.0.0 uniqueness constraints.\n* `cypherStart` becomes redundant.\n* `addUniqueKey` now has a callback, since it is now adding a uniqueness constraint\n  to the database.\n* Saving a model that has its uniqueness set to `returnOld` will now update the\n  existing node's properties on save, to the specified ones (old behaviour was\n  to discard the specified properties, make no changes, and return the existing node).\n* All timestamps are now in milliseconds, and can no longer be customised.\n* New option on `compose`: `updatesTimestamp` - allows the composed node to update\n  the `updated` timestamp of any nodes it is composed upon, when updating. This\n  functionality existed already, but was not optional. It is now opt-in.\n* Both read and write now use only a single API call.\n\n<a name='migration'/>\n# Migration Guide\n\n## to 0.6.0\n\nThis will remove the `nodes` legacy index that was used to keep track of seraph-models\npre 0.6.0. It will label all of the nodes that were in that index with the type of\nthe model. If you specify, it will also migrate your created/updated timestamps.\nYou will need to write your own script to use it.\n\nYou can include the migration function like so:\n\n```\nvar migrate = require('seraph-model/migrations/0.5-to-0.6');\n```\n\nThis function has the following signature:\n\n```\nmigrate(db, models, [migrateTimestamps,] [migrateTimestampsFn,] callback)\n```\n\n* `db` - an instance of seraph pointing to your neo4j db that you want to migrate\n* `models` - an array of your seraph-models that you would like to migrate.\n* `migrateTimestamps` - whether or not this migration should attempt to update your\n  timestamps to the new millisecond-only format\n* `migrateTimestampsFn` - a function to take a timestamp of your old format, and\n  conver it to milliseconds since 1970/01/01. defaults to `function(ts) { return ts * 1000 }`.\n* `callback` - function to call when the migration is complete.\n\n",
  "readmeFilename": "README.md",
  "_id": "seraph-model@0.6.18",
  "dist": {
    "shasum": "4e78e474375aecce5f6473222e82249575ef903a"
  },
  "_from": "seraph-model@0.6.18",
  "_resolved": "https://registry.npmjs.org/seraph-model/-/seraph-model-0.6.18.tgz"
}
